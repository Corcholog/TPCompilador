nombre
BEGIN
	ulongint a, b, c;
	
	ULONGINT FUN funcion1(double parametro)
	BEGIN
		ulongint pepe;
		DOUBLE FUN funcion2(ulongint parametro2)
		BEGIN
			OUTF([SE EJECUTA FUNCION2 QUE ESTA DENTRO DE FUNCION1]);
			RET (parametro);
		END;
		OUTF([EN FUNCION 1]);
		RET (2);
	END;

	a := funcion1(double b);
	b := funcion1(3.0);
	
	IF ( (a, b, c) <= ( 1, 2, 3 + 4 ) ) THEN
	BEGIN
		OUTF([El pattern matching dio true]);
	END
	ELSE
	BEGIN
		OUTF([El pattern matching dio false]);
	END
	END_IF;
	
	IF (d < 12.0) THEN
	BEGIN
		OUTF([se utiliza la variable d que es de tipo embebido, y es menor a 12]);
		OUTF(d);
		IF(d = 0.0) THEN
		BEGIN
			OUTF([d es igual a 0.0 por defecto, esto es un IF anidado]);
		END
		END_IF;
	END
	END_IF;
	
	IF (a < b) THEN
	BEGIN
		OUTF([a era menor a b]);
	END
	ELSE
	BEGIN
		OUTF([a era mayor o igual a b]);
	END	
	END_IF;

	IF (b < a) THEN
	BEGIN
		b := a;
		OUTF( [b era menor que a] );
	END
	END_IF;
	

	ulongint i;
	FOR ( i := 1 ; (i < 10) ; UP 1 ) 
	BEGIN	
		OUTF([ en el for, pero ejecuto una sola vez porque hay GOTO]);
		GOTO PEPE@;
	END;
	OUTF([ESTO NO SE IMPRIME]);
	PEPE@;
	
	ulongint j, k;
	FOR ( i := 1 ; (i < 10) ; UP 1 ) 
	BEGIN	
		OUTF([ en el for, la variable i es: ]);
		OUTF(i);
		IF( i < 5) THEN
		BEGIN
			OUTF([i es menor 5 por lo que se imprimira 3 veces j]);
			FOR ( j := 1 ; (j <= 3) ; UP 1 ) 
			BEGIN	
				OUTF([ en el for, la variable j es: ]);
				OUTF(j);
			END;
		END
		ELSE
		BEGIN
			OUTF([i es mayor o igual 5 por lo que se imprimira 3 veces k]);
			FOR ( k := 1 ; (k <= 3) ; UP 1 ) 
			BEGIN	
				OUTF([ en el for, la variable k es: ]);
				OUTF(k);
			END;
		END
		END_IF;
	END;

	TYPEDEF TRIPLE <double> tripleta;
	tripleta t1, t2, t3;
	
	OUTF([Asignacion a elemento de tripla de double]);
	OUTF([t1{3} era]);
	OUTF(t1{3});
	t1{3} := 1.23d-2;
	OUTF([t1{3} := 1.23d-2]);
	OUTF(t1{3});
	
	t2{3} := 2.0;
	IF (t1 - t2 < t2 + t3) THEN
	BEGIN
		OUTF( [LA COMPARACION DEL PATRON DIO TRUE] );
	END
	END_IF;

	
	t1{1} := t2{3 - 1} * 2.d-23;
	OUTF([MUL ACCTRIPLA t2{3 - 1} * 2.d-23 y se guarda en t1{1}]);
	OUTF(t1{1});
	t1{1} := t2{3 - 1} / 2.d-23;
	OUTF([DIV ACCTRIPLA t2{3 - 1} / 2.d-23 y se guarda en t1{1}]);
	OUTF(t1{1});
	t1{1} := t2{3 - 1} + 2.d-23;
	OUTF([SUMA ACCTRIPLA t2{3 - 1} + 2.d-23 y se guarda en t1{1}]);
	OUTF(t1{1});
	t1{1} := t2{3 - 1} - 2.d-23;
	OUTF([RESTA ACCTRIPLA t2{3 - 1} - 2.d-23]);
	OUTF(t1{1});
	
	t1 := t2 + t3;
	OUTF([SUMA TRIPLA t2 + t3 y se guarda en t1]);
	OUTF(t1);
	t1 := t2 - t3;
	OUTF([RESTA TRIPLA t2 - t3 y se guarda en t1]);
	OUTF(t1);
	t1 := t2 * t3;
	OUTF([MUL TRIPLA t2 * t3 y se guarda en t1]);
	OUTF(t1);
	t1 := t2 / t3;
	OUTF([DIV TRIPLA t2 / t3 y se guarda en t1]);
	OUTF(t1);
	
	double u;
	u := 2.3;
	a := 3;
	
	a := 2 * a;
	OUTF([MUL ULONG 2 * a]);
	OUTF(a);
	a := 7 - a;
	OUTF([RESTA ULONG 7 - a]);
	OUTF(a);
	a := 2 / a;
	OUTF([DIV ULONG 2 / a]);
	OUTF(a);
	a := 2 + a;
	OUTF([SUMA ULONG 2 + a]);
	OUTF(a);
	
	u := 2.0 * u;
	OUTF([MUL DOUBLE 2.0 * u]);
	OUTF(u);
	u := 2.0 - u;
	OUTF([RESTA DOUBLE 2.0 - u]);
	OUTF(u);
	u := 2.0 / u;
	OUTF([DIV DOUBLE 2.0 / u]);
	OUTF(u);
	u := 2.0 + u;
	OUTF([SUMA DOUBLE 2.0 + u]);
	OUTF(u);
	
END